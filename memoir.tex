%%%
% Plantilla de Memoria
% Modificación de una plantilla de Latex de Nicolas Diaz para adaptarla 
% al castellano y a las necesidades de escribir informática y matemáticas.
%
% Editada por: Mario Román
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Thin Sectioned Essay
% LaTeX Template
% Version 1.0 (3/8/13)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original Author:
% Nicolas Diaz (nsdiaz@uc.cl) with extensive modifications by:
% Vel (vel@latextemplates.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%   PAQUETES Y CONFIGURACIÓN DEL DOCUMENTO
%----------------------------------------------------------------------------------------

%%% Configuración del papel.
% microtype: Tipografía.
% mathpazo: Usa la fuente Palatino.
\documentclass[a4paper, 11pt]{article}
\usepackage[protrusion=true,expansion=true]{microtype}
\usepackage{mathpazo}
\usepackage{amsthm}
\usepackage{eurosym}



% Indentación de párrafos para Palatino
\setlength{\parindent}{0pt}
  \parskip=8pt
\linespread{1.05} % Change line spacing here, Palatino benefits from a slight increase by default


%%% Castellano.
% noquoting: Permite uso de comillas no españolas.
% lcroman: Permite la enumeración con numerales romanos en minúscula.
% fontenc: Usa la fuente completa para que pueda copiarse correctamente del pdf.
\usepackage[spanish,es-noquoting,es-lcroman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\selectlanguage{spanish}


%%% Gráficos
\usepackage{graphicx} % Required for including pictures
\usepackage{wrapfig} % Allows in-line images
\usepackage[usenames,dvipsnames]{color} % Coloring code


%%% Matemáticas
\usepackage{amsmath}


%%% Bibliografía
\makeatletter
\renewcommand\@biblabel[1]{\textbf{#1.}} % Change the square brackets for each bibliography item from '[1]' to '1.'
\renewcommand{\@listI}{\itemsep=0pt} % Reduce the space between items in the itemize and enumerate environments and the bibliography



%----------------------------------------------------------------------------------------
%   TÍTULO
%----------------------------------------------------------------------------------------
% Configuraciones para el título.
% El título no debe editarse aquí.
\renewcommand{\maketitle}{
  \begin{flushright} % Right align
  
  {\LARGE\@title} % Increase the font size of the title
  
  \vspace{50pt} % Some vertical space between the title and author name
  
  {\large\@author} % Author name
  \\\@date % Date
  \vspace{40pt} % Some vertical space between the author block and abstract
  \end{flushright}
}

%% Título
\title{\textbf{Algoritmos voraces (greedy)}\\ % Title
Problema de los contenedores} % Subtitle

\author{\textsc{Ignacio Mas Mesa,\\Braulio Valdivielso Martínez} % Author
\\{\textit{Universidad de Granada}}} % Institution

\date{\today} % Date



%----------------------------------------------------------------------------------------
%   DOCUMENTO
%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Print the title section

%% Resumen (Descomentar para usarlo)
\renewcommand{\abstractname}{Resumen} % Uncomment to change the name of the abstract to something else
%\begin{abstract}
% Resumen aquí
%\end{abstract}

%% Palabras clave
%\hspace*{3,6mm}\textit{Keywords:} lorem , ipsum , dolor , sit amet , lectus % Keywords
%\vspace{30pt} % Some vertical space between the abstract and first section


%% Índice
  \tableofcontents

\pagebreak

%%% Inicio del documento

\section{Introducción}
El objetivo de esta práctica es que utilicemos un enfoque \textit{greedy} para resolver un problema planteado.La técnica \textit{greedy} de diseño de algoritmos consiste en tomar en cada paso de resolución de un problema la mejor solución local. Es fácil encontrar ejemplos de problemas en los que un algoritmo \textit{voraz} no encuentra la solución óptima al problema, por lo que parte de la práctica consistirá también es averiguar si el algoritmo greedy diseñado resuelve el problema de forma óptima.

\section{Problema}
Nuestro problema es el siguiente:
\begin{quote}
Se tiene un buque mercante cuya capacidad de carga es de $K$ toneladas y un conjunto de
contenedores $c_1, . . . , c_n$ cuyos pesos respectivos son $p_1, . . . , p_n$ (expresados también en toneladas) y para los que se obtiene un beneficio al ser transportados de $b_1, . . . , b_n$ euros, respectivamente.

Teniendo en cuenta que la capacidad del buque es menor que la suma total de los pesos de los
contenedores:
\begin{enumerate}
\item Diseñe un algoritmo que maximice el número de contenedores cargados, y demuestre su
optimalidad.
\item Diseñe un algoritmo que intente maximizar el beneficio obtenido.
\end{enumerate}
\end{quote}

\section{Solución}
\subsection{Maximizar el número de contenedores}
El primer algoritmo es trivial. Debido a que tenemos que cargar el máximo número de contenedores posible, lo que haremos será coger los contenedores que menos pesen. Este es un algoritmo greedy ya que en cada momento, cogeremos el contenedor que menso pese de los que quedan por coger. La demostración de la optimalidad de este algoritmo es sencilla:
\begin{proof}
Supongamos que $c_1, ..., c_n$ son los contenedores ordenados por peso de menor a mayor, y que la solución óptima viene dada por $ c_{\sigma(n)} $ para $ n \in \{1, ..., k \} $, con $k$ tal que ya no caben más contenedores en el barco. Supongamos que dado $m \in \{1, ..., k\}$,  $c_m \not\in \{\sigma(1), ..., \sigma(k)\} $, pero entonces existe $ s \in \{\sigma(1), ... \sigma(k)\} $ con $ s > k $. Si sustituimos en la colección $c_s$ por $c_m$ tenemos una colección de contenedores que pesa menos que la original, ya que $peso(c_m) < peso(c_s)$ debido a que $m < s$ y los contenedores estaban ordenados por orden de peso. Por este motivo $\{1,...,k\} = \{\sigma(1), ..., \sigma(k)\}$ y entonces no existe combinación de $k$ contenedores que pese menos que aquella en la que los $k$ contenedores son los que menos pesan.
\end{proof}

\subsection{Maximizar el beneficio}
El segundo algoritmo tiene que tratar de maximizar el beneficio. Lo primero que se puede pensar sería coger en cada momento el contenedor que más valor aporte. Sin embargo, esto puede dar lugar a problemas ¿qué ocurre si hay un contenedor que vale un poco más que otro, pero que pesa siete veces más? El algoritmo \textit{naive} cogería el contenedor siete veces más pesado, dejando menos hueco para los siguientes contenedores. Parece que esta heurística no es del todo satisfactoria.

Para resolver este problema, podemos asociar una nueva variable al contenedor que llamaremos \textit{densidad de valor}. El cubo i-ésimo tendrá una densidad de valor $D_i = b_i/p_i$. Así, un contenedor que tenga una densidad de valor muy alta será un contenedor que tenga mucho valor y pese poco.

En cualquier caso, \textbf{ninguno de los dos algoritmos es óptimo}.

\begin{proof}
Veamos que el primer algoritmo no es óptimo. Consideremos una lista de tres contenedores en la que hay un contenedor que pesa 10 toneladas y tiene como valor 10M\euro, los otros dos contenedores tienen peso de 5 toneladas y un valor de 9M\euro. Usar el primer algoritmo para un barco que soporte 10 toneladas nos devolvería que 10M\euro es el beneficio máximo que se puede obtener, mientras que se pueden conseguir 18M\euro cargando los dos contenedores con menor valor.

Veamos que el segundo algoritmo tampoco es óptimo. Consideremos una lista con dos contenedores en la que hay un contenedor que pesa 1kg con valor equivalente a 3M\euro  y otro contenedor que pesa 10 toneladas y tiene un valor equivalente a 4M\euro. En un barco de 10 toneladas, el segundo algoritmo cargaría antes el paquete de 1kg, ya que tiene una gran densidad de valor. Debido a que no quedaría hueco para el segundo contenedor, el beneficio óptimo según este algoritmo sería 3M\euro, cuando en realidad sería 4M\euro de haberse cargado el otro contenedor.

\end{proof}

Por tanto, los dos algoritmos que probaremos para maximizar el valor serán los de elegir el contenedor con más valor y el de elegir el contenedor con mayor densidad de valor. Comprobaremos cuál de los dos obtiene mejores resultados en cuanto a beneficios.

\section{Apéndice: Solución óptima}
Tal y como lo hicimos en la práctica anterior, nos interesamos por encontrar la solución óptima al problema de maximizar el beneficio total que cargar en el barco, ya que como demostramos, la solución greedy tiene algunos problemas.

Tras nuestras investigaciones, pudimos encontrar que este problema es un problema conocido en la literatura como ``\textit{el problema de la mochila}''. La solución óptima de este programa pasa por usar una técnica de diseño de algoritmos llamada \textit{programación dinámica}, que veremos próximamente.

Utilizamos el lenguaje de programación python para realizar la implementación del algoritmo más cómoda y rápidamente.	

\end{document}